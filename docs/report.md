# Secure Student Management System

## Abstract
This project delivers a Flask-based student management platform hardened with multi-layered security, including multi-factor authentication, encrypted storage, rigorous input validation, and monitoring capabilities. The solution enables authorized stakeholders to manage student data safely while providing auditability and integration paths.

## Introduction
Educational institutions process sensitive personal and academic data that must be protected against credential theft, data tampering, and privacy breaches. The Secure Student Management System (SMS) demonstrates how modern web security practices—such as strong authentication, least-privilege access control, and encryption—can be combined to mitigate common web threats including SQL injection and cross-site scripting (XSS).

## Implementation Overview
### Authentication and 2FA
* Passwords are hashed with bcrypt before persistence.
* Users authenticate via a three-step challenge: password, email-delivered one-time password (OTP), and Time-based OTP (TOTP) generated by an authenticator app. A biometric passphrase acts as a proxy for biometric authentication.
* QR codes simplify enrollment with Google Authenticator or similar apps.

### Encryption and Secure Storage
* Sensitive student attributes are serialized and encrypted with AES-128-GCM (via `cryptography`'s Fernet implementation) before storage in SQLite.
* Encryption keys are loaded from environment variables when available and otherwise persisted to a permissions-restricted file.

### Input Validation and XSS Prevention
* Flask-WTF validates all forms server-side.
* Inputs are sanitized using `bleach.clean`, and templates leverage Jinja2 auto-escaping to avoid reflected XSS vectors.

### Role-Based Access Control (RBAC)
* Roles (`admin`, `teacher`, `student`) gate access to routes through custom decorators.
* Administrators manage users and backups; teachers handle CRUD operations on students; students receive read-only access.

### Secure CRUD Operations
* Student records are encrypted in the database and decrypted only in-memory for display.
* Actions (create, update, delete) are logged with user attribution and IP metadata to enable forensic reviews.

### Additional Features
* Activity log page with chronological events and severity context.
* JWT issuance endpoint for third-party integrations.
* Dark mode UI toggle persisted via `localStorage`.
* Database backup download for secure off-site retention.
* Dashboard analytics rendering grade distributions with Chart.js.

## Results
Screenshots of the user interface, authentication flow, and analytics dashboard can be produced by running the Flask app (`python app.py`) and capturing the rendered pages. The default admin credentials are `admin` / `ChangeMe123!` with biometric phrase `default-biometric`; update them immediately after first login.

## Challenges and Future Work
* Email delivery and biometric verification are simulated; integrating with production-grade providers (SMTP, WebAuthn, device biometrics) is recommended.
* SQLite is suitable for demonstrations; migrating to a managed database with transparent encryption (e.g., PostgreSQL + pgcrypto) would enhance scalability.
* Future enhancements include REST APIs for institutional integration, automated GDPR data anonymization workflows, and real-time notification pipelines.

## How to Run
1. Create a Python virtual environment and install dependencies from `requirements.txt` (or install Flask, Flask-WTF, Flask-Bcrypt, SQLAlchemy, pyotp, cryptography, jwt, and bleach manually).
2. Set `FLASK_SECRET`, `JWT_SECRET`, and `ENCRYPTION_KEY` environment variables for production deployments.
3. Start the application with `python app.py`. The database and a default admin user are created automatically if they do not exist.
4. Access the dashboard at `http://localhost:5000` and follow the prompts to authenticate.
